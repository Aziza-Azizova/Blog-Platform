"use strict";Object.defineProperty(exports,"__esModule",{value:true});function _export(target,all){for(var name in all)Object.defineProperty(target,name,{enumerable:true,get:all[name]})}_export(exports,{UserService:function(){return UserService},generateAccessToken:function(){return generateAccessToken}});const _Usermodel=require("./User.model");const _jsonwebtoken=/*#__PURE__*/_interop_require_default(require("jsonwebtoken"));const _dotenv=/*#__PURE__*/_interop_require_default(require("dotenv"));const _errors=require("../../shared/exceptions/errors");function _interop_require_default(obj){return obj&&obj.__esModule?obj:{default:obj}}_dotenv.default.config();const jwtKey=process.env.JWT_SECRET_KEY;function generateAccessToken(id,roles){const payload={id,roles};return _jsonwebtoken.default.sign(payload,jwtKey,{expiresIn:"1h"})}let UserService=class UserService{static async register(req,res){const{email,username,password}=req.body;const existingEmail=await _Usermodel.User.findOne({email});if(existingEmail){throw new _errors.ConflictError("Email already exists")}const newUser=new _Usermodel.User({email,username,password});await newUser.save();return newUser}static async login(req,res){const{email,password}=req.body;const registeredUser=await _Usermodel.User.findOne({email});if(!registeredUser){throw new _errors.NotFoundError("User not found")}const isValidUserPassword=await registeredUser.isValidPassword(password);if(!isValidUserPassword){throw new _errors.UnauthorizedError("Wrong password")}const token=generateAccessToken(registeredUser._id,registeredUser.roles);return{user:registeredUser,token}}};